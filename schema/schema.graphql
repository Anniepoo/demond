schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "chat"
type chat {
  contents: String!
  id: Int!
  player: Int!
  time: timestamptz!
}

# aggregated selection of "chat"
type chat_aggregate {
  aggregate: chat_aggregate_fields
  nodes: [chat!]!
}

# aggregate fields of "chat"
type chat_aggregate_fields {
  avg: chat_avg_fields
  count(columns: [chat_select_column!], distinct: Boolean): Int
  max: chat_max_fields
  min: chat_min_fields
  stddev: chat_stddev_fields
  stddev_pop: chat_stddev_pop_fields
  stddev_samp: chat_stddev_samp_fields
  sum: chat_sum_fields
  var_pop: chat_var_pop_fields
  var_samp: chat_var_samp_fields
  variance: chat_variance_fields
}

# order by aggregate values of table "chat"
input chat_aggregate_order_by {
  avg: chat_avg_order_by
  count: order_by
  max: chat_max_order_by
  min: chat_min_order_by
  stddev: chat_stddev_order_by
  stddev_pop: chat_stddev_pop_order_by
  stddev_samp: chat_stddev_samp_order_by
  sum: chat_sum_order_by
  var_pop: chat_var_pop_order_by
  var_samp: chat_var_samp_order_by
  variance: chat_variance_order_by
}

# input type for inserting array relation for remote table "chat"
input chat_arr_rel_insert_input {
  data: [chat_insert_input!]!
  on_conflict: chat_on_conflict
}

# aggregate avg on columns
type chat_avg_fields {
  id: Float
  player: Float
}

# order by avg() on columns of table "chat"
input chat_avg_order_by {
  id: order_by
  player: order_by
}

# Boolean expression to filter rows from the table "chat". All fields are combined with a logical 'AND'.
input chat_bool_exp {
  _and: [chat_bool_exp]
  _not: chat_bool_exp
  _or: [chat_bool_exp]
  contents: text_comparison_exp
  id: integer_comparison_exp
  player: integer_comparison_exp
  time: timestamptz_comparison_exp
}

# unique or primary key constraints on table "chat"
enum chat_constraint {
  # unique or primary key constraint
  chat_pkey
}

# input type for incrementing integer columne in table "chat"
input chat_inc_input {
  id: Int
  player: Int
}

# input type for inserting data into table "chat"
input chat_insert_input {
  contents: String
  id: Int
  player: Int
  time: timestamptz
}

# aggregate max on columns
type chat_max_fields {
  contents: String
  id: Int
  player: Int
  time: timestamptz
}

# order by max() on columns of table "chat"
input chat_max_order_by {
  contents: order_by
  id: order_by
  player: order_by
  time: order_by
}

# aggregate min on columns
type chat_min_fields {
  contents: String
  id: Int
  player: Int
  time: timestamptz
}

# order by min() on columns of table "chat"
input chat_min_order_by {
  contents: order_by
  id: order_by
  player: order_by
  time: order_by
}

# response of any mutation on the table "chat"
type chat_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [chat!]!
}

# input type for inserting object relation for remote table "chat"
input chat_obj_rel_insert_input {
  data: chat_insert_input!
  on_conflict: chat_on_conflict
}

# on conflict condition type for table "chat"
input chat_on_conflict {
  constraint: chat_constraint!
  update_columns: [chat_update_column!]!
}

# ordering options when selecting data from "chat"
input chat_order_by {
  contents: order_by
  id: order_by
  player: order_by
  time: order_by
}

# select columns of table "chat"
enum chat_select_column {
  # column name
  contents

  # column name
  id

  # column name
  player

  # column name
  time
}

# input type for updating data in table "chat"
input chat_set_input {
  contents: String
  id: Int
  player: Int
  time: timestamptz
}

# aggregate stddev on columns
type chat_stddev_fields {
  id: Float
  player: Float
}

# order by stddev() on columns of table "chat"
input chat_stddev_order_by {
  id: order_by
  player: order_by
}

# aggregate stddev_pop on columns
type chat_stddev_pop_fields {
  id: Float
  player: Float
}

# order by stddev_pop() on columns of table "chat"
input chat_stddev_pop_order_by {
  id: order_by
  player: order_by
}

# aggregate stddev_samp on columns
type chat_stddev_samp_fields {
  id: Float
  player: Float
}

# order by stddev_samp() on columns of table "chat"
input chat_stddev_samp_order_by {
  id: order_by
  player: order_by
}

# aggregate sum on columns
type chat_sum_fields {
  id: Int
  player: Int
}

# order by sum() on columns of table "chat"
input chat_sum_order_by {
  id: order_by
  player: order_by
}

# update columns of table "chat"
enum chat_update_column {
  # column name
  contents

  # column name
  id

  # column name
  player

  # column name
  time
}

# aggregate var_pop on columns
type chat_var_pop_fields {
  id: Float
  player: Float
}

# order by var_pop() on columns of table "chat"
input chat_var_pop_order_by {
  id: order_by
  player: order_by
}

# aggregate var_samp on columns
type chat_var_samp_fields {
  id: Float
  player: Float
}

# order by var_samp() on columns of table "chat"
input chat_var_samp_order_by {
  id: order_by
  player: order_by
}

# aggregate variance on columns
type chat_variance_fields {
  id: Float
  player: Float
}

# order by variance() on columns of table "chat"
input chat_variance_order_by {
  id: order_by
  player: order_by
}

# conflict action
enum conflict_action {
  # ignore the insert on this row
  ignore

  # update the row with the given values
  update
}

# columns and relationships of "enough_players"
type enough_players {
  root: json
}

# aggregated selection of "enough_players"
type enough_players_aggregate {
  aggregate: enough_players_aggregate_fields
  nodes: [enough_players!]!
}

# aggregate fields of "enough_players"
type enough_players_aggregate_fields {
  count(columns: [enough_players_select_column!], distinct: Boolean): Int
}

# order by aggregate values of table "enough_players"
input enough_players_aggregate_order_by {
  count: order_by
}

# Boolean expression to filter rows from the table "enough_players". All fields are combined with a logical 'AND'.
input enough_players_bool_exp {
  _and: [enough_players_bool_exp]
  _not: enough_players_bool_exp
  _or: [enough_players_bool_exp]
  root: json_comparison_exp
}

# ordering options when selecting data from "enough_players"
input enough_players_order_by {
  root: order_by
}

# select columns of table "enough_players"
enum enough_players_select_column {
  # column name
  root
}

# expression to compare columns of type integer. All fields are combined with logical 'AND'.
input integer_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int]
}

scalar json

# expression to compare columns of type json. All fields are combined with logical 'AND'.
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json]
}

# mutation root
type mutation_root {
  # delete data from the table: "chat"
  delete_chat(
    # filter the rows which have to be deleted
    where: chat_bool_exp!
  ): chat_mutation_response

  # delete data from the table: "players"
  delete_players(
    # filter the rows which have to be deleted
    where: players_bool_exp!
  ): players_mutation_response

  # delete data from the table: "powerups"
  delete_powerups(
    # filter the rows which have to be deleted
    where: powerups_bool_exp!
  ): powerups_mutation_response

  # delete data from the table: "towers"
  delete_towers(
    # filter the rows which have to be deleted
    where: towers_bool_exp!
  ): towers_mutation_response

  # insert data into the table: "chat"
  insert_chat(
    # the rows to be inserted
    objects: [chat_insert_input!]!

    # on conflict condition
    on_conflict: chat_on_conflict
  ): chat_mutation_response

  # insert data into the table: "players"
  insert_players(
    # the rows to be inserted
    objects: [players_insert_input!]!

    # on conflict condition
    on_conflict: players_on_conflict
  ): players_mutation_response

  # insert data into the table: "powerups"
  insert_powerups(
    # the rows to be inserted
    objects: [powerups_insert_input!]!

    # on conflict condition
    on_conflict: powerups_on_conflict
  ): powerups_mutation_response

  # insert data into the table: "towers"
  insert_towers(
    # the rows to be inserted
    objects: [towers_insert_input!]!

    # on conflict condition
    on_conflict: towers_on_conflict
  ): towers_mutation_response

  # update data of the table: "chat"
  update_chat(
    # increments the integer columns with given value of the filtered values
    _inc: chat_inc_input

    # sets the columns of the filtered rows to the given values
    _set: chat_set_input

    # filter the rows which have to be updated
    where: chat_bool_exp!
  ): chat_mutation_response

  # update data of the table: "players"
  update_players(
    # increments the integer columns with given value of the filtered values
    _inc: players_inc_input

    # sets the columns of the filtered rows to the given values
    _set: players_set_input

    # filter the rows which have to be updated
    where: players_bool_exp!
  ): players_mutation_response

  # update data of the table: "powerups"
  update_powerups(
    # increments the integer columns with given value of the filtered values
    _inc: powerups_inc_input

    # sets the columns of the filtered rows to the given values
    _set: powerups_set_input

    # filter the rows which have to be updated
    where: powerups_bool_exp!
  ): powerups_mutation_response

  # update data of the table: "towers"
  update_towers(
    # increments the integer columns with given value of the filtered values
    _inc: towers_inc_input

    # sets the columns of the filtered rows to the given values
    _set: towers_set_input

    # filter the rows which have to be updated
    where: towers_bool_exp!
  ): towers_mutation_response
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "players"
type players {
  breath: numeric!
  id: Int!
  lastseen: timestamptz
  name: String!
  xpos: numeric!
  xvel: numeric!
  ypos: numeric!
  yvel: numeric!
}

# aggregated selection of "players"
type players_aggregate {
  aggregate: players_aggregate_fields
  nodes: [players!]!
}

# aggregate fields of "players"
type players_aggregate_fields {
  avg: players_avg_fields
  count(columns: [players_select_column!], distinct: Boolean): Int
  max: players_max_fields
  min: players_min_fields
  stddev: players_stddev_fields
  stddev_pop: players_stddev_pop_fields
  stddev_samp: players_stddev_samp_fields
  sum: players_sum_fields
  var_pop: players_var_pop_fields
  var_samp: players_var_samp_fields
  variance: players_variance_fields
}

# order by aggregate values of table "players"
input players_aggregate_order_by {
  avg: players_avg_order_by
  count: order_by
  max: players_max_order_by
  min: players_min_order_by
  stddev: players_stddev_order_by
  stddev_pop: players_stddev_pop_order_by
  stddev_samp: players_stddev_samp_order_by
  sum: players_sum_order_by
  var_pop: players_var_pop_order_by
  var_samp: players_var_samp_order_by
  variance: players_variance_order_by
}

# input type for inserting array relation for remote table "players"
input players_arr_rel_insert_input {
  data: [players_insert_input!]!
  on_conflict: players_on_conflict
}

# aggregate avg on columns
type players_avg_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by avg() on columns of table "players"
input players_avg_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# Boolean expression to filter rows from the table "players". All fields are combined with a logical 'AND'.
input players_bool_exp {
  _and: [players_bool_exp]
  _not: players_bool_exp
  _or: [players_bool_exp]
  breath: numeric_comparison_exp
  id: integer_comparison_exp
  lastseen: timestamptz_comparison_exp
  name: text_comparison_exp
  xpos: numeric_comparison_exp
  xvel: numeric_comparison_exp
  ypos: numeric_comparison_exp
  yvel: numeric_comparison_exp
}

# unique or primary key constraints on table "players"
enum players_constraint {
  # unique or primary key constraint
  players_pkey
}

# input type for incrementing integer columne in table "players"
input players_inc_input {
  id: Int
}

# input type for inserting data into table "players"
input players_insert_input {
  breath: numeric
  id: Int
  lastseen: timestamptz
  name: String
  xpos: numeric
  xvel: numeric
  ypos: numeric
  yvel: numeric
}

# aggregate max on columns
type players_max_fields {
  breath: numeric
  id: Int
  lastseen: timestamptz
  name: String
  xpos: numeric
  xvel: numeric
  ypos: numeric
  yvel: numeric
}

# order by max() on columns of table "players"
input players_max_order_by {
  breath: order_by
  id: order_by
  lastseen: order_by
  name: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# aggregate min on columns
type players_min_fields {
  breath: numeric
  id: Int
  lastseen: timestamptz
  name: String
  xpos: numeric
  xvel: numeric
  ypos: numeric
  yvel: numeric
}

# order by min() on columns of table "players"
input players_min_order_by {
  breath: order_by
  id: order_by
  lastseen: order_by
  name: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# response of any mutation on the table "players"
type players_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [players!]!
}

# input type for inserting object relation for remote table "players"
input players_obj_rel_insert_input {
  data: players_insert_input!
  on_conflict: players_on_conflict
}

# on conflict condition type for table "players"
input players_on_conflict {
  constraint: players_constraint!
  update_columns: [players_update_column!]!
}

# ordering options when selecting data from "players"
input players_order_by {
  breath: order_by
  id: order_by
  lastseen: order_by
  name: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# select columns of table "players"
enum players_select_column {
  # column name
  breath

  # column name
  id

  # column name
  lastseen

  # column name
  name

  # column name
  xpos

  # column name
  xvel

  # column name
  ypos

  # column name
  yvel
}

# input type for updating data in table "players"
input players_set_input {
  breath: numeric
  id: Int
  lastseen: timestamptz
  name: String
  xpos: numeric
  xvel: numeric
  ypos: numeric
  yvel: numeric
}

# aggregate stddev on columns
type players_stddev_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by stddev() on columns of table "players"
input players_stddev_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# aggregate stddev_pop on columns
type players_stddev_pop_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by stddev_pop() on columns of table "players"
input players_stddev_pop_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# aggregate stddev_samp on columns
type players_stddev_samp_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by stddev_samp() on columns of table "players"
input players_stddev_samp_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# aggregate sum on columns
type players_sum_fields {
  breath: numeric
  id: Int
  xpos: numeric
  xvel: numeric
  ypos: numeric
  yvel: numeric
}

# order by sum() on columns of table "players"
input players_sum_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# update columns of table "players"
enum players_update_column {
  # column name
  breath

  # column name
  id

  # column name
  lastseen

  # column name
  name

  # column name
  xpos

  # column name
  xvel

  # column name
  ypos

  # column name
  yvel
}

# aggregate var_pop on columns
type players_var_pop_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by var_pop() on columns of table "players"
input players_var_pop_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# aggregate var_samp on columns
type players_var_samp_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by var_samp() on columns of table "players"
input players_var_samp_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# aggregate variance on columns
type players_variance_fields {
  breath: Float
  id: Float
  xpos: Float
  xvel: Float
  ypos: Float
  yvel: Float
}

# order by variance() on columns of table "players"
input players_variance_order_by {
  breath: order_by
  id: order_by
  xpos: order_by
  xvel: order_by
  ypos: order_by
  yvel: order_by
}

# columns and relationships of "powerups"
type powerups {
  id: Int!
  type: String!
  xpos: numeric!
  ypos: numeric!
}

# aggregated selection of "powerups"
type powerups_aggregate {
  aggregate: powerups_aggregate_fields
  nodes: [powerups!]!
}

# aggregate fields of "powerups"
type powerups_aggregate_fields {
  avg: powerups_avg_fields
  count(columns: [powerups_select_column!], distinct: Boolean): Int
  max: powerups_max_fields
  min: powerups_min_fields
  stddev: powerups_stddev_fields
  stddev_pop: powerups_stddev_pop_fields
  stddev_samp: powerups_stddev_samp_fields
  sum: powerups_sum_fields
  var_pop: powerups_var_pop_fields
  var_samp: powerups_var_samp_fields
  variance: powerups_variance_fields
}

# order by aggregate values of table "powerups"
input powerups_aggregate_order_by {
  avg: powerups_avg_order_by
  count: order_by
  max: powerups_max_order_by
  min: powerups_min_order_by
  stddev: powerups_stddev_order_by
  stddev_pop: powerups_stddev_pop_order_by
  stddev_samp: powerups_stddev_samp_order_by
  sum: powerups_sum_order_by
  var_pop: powerups_var_pop_order_by
  var_samp: powerups_var_samp_order_by
  variance: powerups_variance_order_by
}

# input type for inserting array relation for remote table "powerups"
input powerups_arr_rel_insert_input {
  data: [powerups_insert_input!]!
  on_conflict: powerups_on_conflict
}

# aggregate avg on columns
type powerups_avg_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by avg() on columns of table "powerups"
input powerups_avg_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# Boolean expression to filter rows from the table "powerups". All fields are combined with a logical 'AND'.
input powerups_bool_exp {
  _and: [powerups_bool_exp]
  _not: powerups_bool_exp
  _or: [powerups_bool_exp]
  id: integer_comparison_exp
  type: text_comparison_exp
  xpos: numeric_comparison_exp
  ypos: numeric_comparison_exp
}

# unique or primary key constraints on table "powerups"
enum powerups_constraint {
  # unique or primary key constraint
  powerups_pkey
}

# input type for incrementing integer columne in table "powerups"
input powerups_inc_input {
  id: Int
}

# input type for inserting data into table "powerups"
input powerups_insert_input {
  id: Int
  type: String
  xpos: numeric
  ypos: numeric
}

# aggregate max on columns
type powerups_max_fields {
  id: Int
  type: String
  xpos: numeric
  ypos: numeric
}

# order by max() on columns of table "powerups"
input powerups_max_order_by {
  id: order_by
  type: order_by
  xpos: order_by
  ypos: order_by
}

# aggregate min on columns
type powerups_min_fields {
  id: Int
  type: String
  xpos: numeric
  ypos: numeric
}

# order by min() on columns of table "powerups"
input powerups_min_order_by {
  id: order_by
  type: order_by
  xpos: order_by
  ypos: order_by
}

# response of any mutation on the table "powerups"
type powerups_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [powerups!]!
}

# input type for inserting object relation for remote table "powerups"
input powerups_obj_rel_insert_input {
  data: powerups_insert_input!
  on_conflict: powerups_on_conflict
}

# on conflict condition type for table "powerups"
input powerups_on_conflict {
  constraint: powerups_constraint!
  update_columns: [powerups_update_column!]!
}

# ordering options when selecting data from "powerups"
input powerups_order_by {
  id: order_by
  type: order_by
  xpos: order_by
  ypos: order_by
}

# select columns of table "powerups"
enum powerups_select_column {
  # column name
  id

  # column name
  type

  # column name
  xpos

  # column name
  ypos
}

# input type for updating data in table "powerups"
input powerups_set_input {
  id: Int
  type: String
  xpos: numeric
  ypos: numeric
}

# aggregate stddev on columns
type powerups_stddev_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by stddev() on columns of table "powerups"
input powerups_stddev_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# aggregate stddev_pop on columns
type powerups_stddev_pop_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by stddev_pop() on columns of table "powerups"
input powerups_stddev_pop_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# aggregate stddev_samp on columns
type powerups_stddev_samp_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by stddev_samp() on columns of table "powerups"
input powerups_stddev_samp_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# aggregate sum on columns
type powerups_sum_fields {
  id: Int
  xpos: numeric
  ypos: numeric
}

# order by sum() on columns of table "powerups"
input powerups_sum_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# update columns of table "powerups"
enum powerups_update_column {
  # column name
  id

  # column name
  type

  # column name
  xpos

  # column name
  ypos
}

# aggregate var_pop on columns
type powerups_var_pop_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by var_pop() on columns of table "powerups"
input powerups_var_pop_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# aggregate var_samp on columns
type powerups_var_samp_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by var_samp() on columns of table "powerups"
input powerups_var_samp_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# aggregate variance on columns
type powerups_variance_fields {
  id: Float
  xpos: Float
  ypos: Float
}

# order by variance() on columns of table "powerups"
input powerups_variance_order_by {
  id: order_by
  xpos: order_by
  ypos: order_by
}

# query root
type query_root {
  # fetch data from the table: "chat"
  chat(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): [chat!]!

  # fetch aggregated fields from the table: "chat"
  chat_aggregate(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): chat_aggregate!

  # fetch data from the table: "chat" using primary key columns
  chat_by_pk(id: Int!): chat

  # fetch data from the table: "enough_players"
  enough_players(
    # distinct select on columns
    distinct_on: [enough_players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enough_players_order_by!]

    # filter the rows returned
    where: enough_players_bool_exp
  ): [enough_players!]!

  # fetch aggregated fields from the table: "enough_players"
  enough_players_aggregate(
    # distinct select on columns
    distinct_on: [enough_players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enough_players_order_by!]

    # filter the rows returned
    where: enough_players_bool_exp
  ): enough_players_aggregate!

  # fetch data from the table: "players"
  players(
    # distinct select on columns
    distinct_on: [players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [players_order_by!]

    # filter the rows returned
    where: players_bool_exp
  ): [players!]!

  # fetch aggregated fields from the table: "players"
  players_aggregate(
    # distinct select on columns
    distinct_on: [players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [players_order_by!]

    # filter the rows returned
    where: players_bool_exp
  ): players_aggregate!

  # fetch data from the table: "players" using primary key columns
  players_by_pk(id: Int!): players

  # fetch data from the table: "powerups"
  powerups(
    # distinct select on columns
    distinct_on: [powerups_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [powerups_order_by!]

    # filter the rows returned
    where: powerups_bool_exp
  ): [powerups!]!

  # fetch aggregated fields from the table: "powerups"
  powerups_aggregate(
    # distinct select on columns
    distinct_on: [powerups_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [powerups_order_by!]

    # filter the rows returned
    where: powerups_bool_exp
  ): powerups_aggregate!

  # fetch data from the table: "powerups" using primary key columns
  powerups_by_pk(id: Int!): powerups

  # fetch data from the table: "recentchat"
  recentchat(
    # distinct select on columns
    distinct_on: [recentchat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [recentchat_order_by!]

    # filter the rows returned
    where: recentchat_bool_exp
  ): [recentchat!]!

  # fetch aggregated fields from the table: "recentchat"
  recentchat_aggregate(
    # distinct select on columns
    distinct_on: [recentchat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [recentchat_order_by!]

    # filter the rows returned
    where: recentchat_bool_exp
  ): recentchat_aggregate!

  # fetch data from the table: "towers"
  towers(
    # distinct select on columns
    distinct_on: [towers_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [towers_order_by!]

    # filter the rows returned
    where: towers_bool_exp
  ): [towers!]!

  # fetch aggregated fields from the table: "towers"
  towers_aggregate(
    # distinct select on columns
    distinct_on: [towers_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [towers_order_by!]

    # filter the rows returned
    where: towers_bool_exp
  ): towers_aggregate!

  # fetch data from the table: "towers" using primary key columns
  towers_by_pk(id: Int!): towers
}

# columns and relationships of "recentchat"
type recentchat {
  contents: String
  id: Int
  name: String
  player: Int
  time: timestamptz
}

# aggregated selection of "recentchat"
type recentchat_aggregate {
  aggregate: recentchat_aggregate_fields
  nodes: [recentchat!]!
}

# aggregate fields of "recentchat"
type recentchat_aggregate_fields {
  avg: recentchat_avg_fields
  count(columns: [recentchat_select_column!], distinct: Boolean): Int
  max: recentchat_max_fields
  min: recentchat_min_fields
  stddev: recentchat_stddev_fields
  stddev_pop: recentchat_stddev_pop_fields
  stddev_samp: recentchat_stddev_samp_fields
  sum: recentchat_sum_fields
  var_pop: recentchat_var_pop_fields
  var_samp: recentchat_var_samp_fields
  variance: recentchat_variance_fields
}

# order by aggregate values of table "recentchat"
input recentchat_aggregate_order_by {
  avg: recentchat_avg_order_by
  count: order_by
  max: recentchat_max_order_by
  min: recentchat_min_order_by
  stddev: recentchat_stddev_order_by
  stddev_pop: recentchat_stddev_pop_order_by
  stddev_samp: recentchat_stddev_samp_order_by
  sum: recentchat_sum_order_by
  var_pop: recentchat_var_pop_order_by
  var_samp: recentchat_var_samp_order_by
  variance: recentchat_variance_order_by
}

# aggregate avg on columns
type recentchat_avg_fields {
  id: Float
  player: Float
}

# order by avg() on columns of table "recentchat"
input recentchat_avg_order_by {
  id: order_by
  player: order_by
}

# Boolean expression to filter rows from the table "recentchat". All fields are combined with a logical 'AND'.
input recentchat_bool_exp {
  _and: [recentchat_bool_exp]
  _not: recentchat_bool_exp
  _or: [recentchat_bool_exp]
  contents: text_comparison_exp
  id: integer_comparison_exp
  name: text_comparison_exp
  player: integer_comparison_exp
  time: timestamptz_comparison_exp
}

# aggregate max on columns
type recentchat_max_fields {
  contents: String
  id: Int
  name: String
  player: Int
  time: timestamptz
}

# order by max() on columns of table "recentchat"
input recentchat_max_order_by {
  contents: order_by
  id: order_by
  name: order_by
  player: order_by
  time: order_by
}

# aggregate min on columns
type recentchat_min_fields {
  contents: String
  id: Int
  name: String
  player: Int
  time: timestamptz
}

# order by min() on columns of table "recentchat"
input recentchat_min_order_by {
  contents: order_by
  id: order_by
  name: order_by
  player: order_by
  time: order_by
}

# ordering options when selecting data from "recentchat"
input recentchat_order_by {
  contents: order_by
  id: order_by
  name: order_by
  player: order_by
  time: order_by
}

# select columns of table "recentchat"
enum recentchat_select_column {
  # column name
  contents

  # column name
  id

  # column name
  name

  # column name
  player

  # column name
  time
}

# aggregate stddev on columns
type recentchat_stddev_fields {
  id: Float
  player: Float
}

# order by stddev() on columns of table "recentchat"
input recentchat_stddev_order_by {
  id: order_by
  player: order_by
}

# aggregate stddev_pop on columns
type recentchat_stddev_pop_fields {
  id: Float
  player: Float
}

# order by stddev_pop() on columns of table "recentchat"
input recentchat_stddev_pop_order_by {
  id: order_by
  player: order_by
}

# aggregate stddev_samp on columns
type recentchat_stddev_samp_fields {
  id: Float
  player: Float
}

# order by stddev_samp() on columns of table "recentchat"
input recentchat_stddev_samp_order_by {
  id: order_by
  player: order_by
}

# aggregate sum on columns
type recentchat_sum_fields {
  id: Int
  player: Int
}

# order by sum() on columns of table "recentchat"
input recentchat_sum_order_by {
  id: order_by
  player: order_by
}

# aggregate var_pop on columns
type recentchat_var_pop_fields {
  id: Float
  player: Float
}

# order by var_pop() on columns of table "recentchat"
input recentchat_var_pop_order_by {
  id: order_by
  player: order_by
}

# aggregate var_samp on columns
type recentchat_var_samp_fields {
  id: Float
  player: Float
}

# order by var_samp() on columns of table "recentchat"
input recentchat_var_samp_order_by {
  id: order_by
  player: order_by
}

# aggregate variance on columns
type recentchat_variance_fields {
  id: Float
  player: Float
}

# order by variance() on columns of table "recentchat"
input recentchat_variance_order_by {
  id: order_by
  player: order_by
}

# subscription root
type subscription_root {
  # fetch data from the table: "chat"
  chat(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): [chat!]!

  # fetch aggregated fields from the table: "chat"
  chat_aggregate(
    # distinct select on columns
    distinct_on: [chat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [chat_order_by!]

    # filter the rows returned
    where: chat_bool_exp
  ): chat_aggregate!

  # fetch data from the table: "chat" using primary key columns
  chat_by_pk(id: Int!): chat

  # fetch data from the table: "enough_players"
  enough_players(
    # distinct select on columns
    distinct_on: [enough_players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enough_players_order_by!]

    # filter the rows returned
    where: enough_players_bool_exp
  ): [enough_players!]!

  # fetch aggregated fields from the table: "enough_players"
  enough_players_aggregate(
    # distinct select on columns
    distinct_on: [enough_players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [enough_players_order_by!]

    # filter the rows returned
    where: enough_players_bool_exp
  ): enough_players_aggregate!

  # fetch data from the table: "players"
  players(
    # distinct select on columns
    distinct_on: [players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [players_order_by!]

    # filter the rows returned
    where: players_bool_exp
  ): [players!]!

  # fetch aggregated fields from the table: "players"
  players_aggregate(
    # distinct select on columns
    distinct_on: [players_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [players_order_by!]

    # filter the rows returned
    where: players_bool_exp
  ): players_aggregate!

  # fetch data from the table: "players" using primary key columns
  players_by_pk(id: Int!): players

  # fetch data from the table: "powerups"
  powerups(
    # distinct select on columns
    distinct_on: [powerups_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [powerups_order_by!]

    # filter the rows returned
    where: powerups_bool_exp
  ): [powerups!]!

  # fetch aggregated fields from the table: "powerups"
  powerups_aggregate(
    # distinct select on columns
    distinct_on: [powerups_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [powerups_order_by!]

    # filter the rows returned
    where: powerups_bool_exp
  ): powerups_aggregate!

  # fetch data from the table: "powerups" using primary key columns
  powerups_by_pk(id: Int!): powerups

  # fetch data from the table: "recentchat"
  recentchat(
    # distinct select on columns
    distinct_on: [recentchat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [recentchat_order_by!]

    # filter the rows returned
    where: recentchat_bool_exp
  ): [recentchat!]!

  # fetch aggregated fields from the table: "recentchat"
  recentchat_aggregate(
    # distinct select on columns
    distinct_on: [recentchat_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [recentchat_order_by!]

    # filter the rows returned
    where: recentchat_bool_exp
  ): recentchat_aggregate!

  # fetch data from the table: "towers"
  towers(
    # distinct select on columns
    distinct_on: [towers_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [towers_order_by!]

    # filter the rows returned
    where: towers_bool_exp
  ): [towers!]!

  # fetch aggregated fields from the table: "towers"
  towers_aggregate(
    # distinct select on columns
    distinct_on: [towers_select_column!]

    # limit the nuber of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [towers_order_by!]

    # filter the rows returned
    where: towers_bool_exp
  ): towers_aggregate!

  # fetch data from the table: "towers" using primary key columns
  towers_by_pk(id: Int!): towers
}

# expression to compare columns of type text. All fields are combined with logical 'AND'.
input text_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String]
  _nlike: String
  _nsimilar: String
  _similar: String
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz]
}

# columns and relationships of "towers"
type towers {
  col: Int!
  id: Int!
  progress: numeric!
  row: Int!
}

# aggregated selection of "towers"
type towers_aggregate {
  aggregate: towers_aggregate_fields
  nodes: [towers!]!
}

# aggregate fields of "towers"
type towers_aggregate_fields {
  avg: towers_avg_fields
  count(columns: [towers_select_column!], distinct: Boolean): Int
  max: towers_max_fields
  min: towers_min_fields
  stddev: towers_stddev_fields
  stddev_pop: towers_stddev_pop_fields
  stddev_samp: towers_stddev_samp_fields
  sum: towers_sum_fields
  var_pop: towers_var_pop_fields
  var_samp: towers_var_samp_fields
  variance: towers_variance_fields
}

# order by aggregate values of table "towers"
input towers_aggregate_order_by {
  avg: towers_avg_order_by
  count: order_by
  max: towers_max_order_by
  min: towers_min_order_by
  stddev: towers_stddev_order_by
  stddev_pop: towers_stddev_pop_order_by
  stddev_samp: towers_stddev_samp_order_by
  sum: towers_sum_order_by
  var_pop: towers_var_pop_order_by
  var_samp: towers_var_samp_order_by
  variance: towers_variance_order_by
}

# input type for inserting array relation for remote table "towers"
input towers_arr_rel_insert_input {
  data: [towers_insert_input!]!
  on_conflict: towers_on_conflict
}

# aggregate avg on columns
type towers_avg_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by avg() on columns of table "towers"
input towers_avg_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# Boolean expression to filter rows from the table "towers". All fields are combined with a logical 'AND'.
input towers_bool_exp {
  _and: [towers_bool_exp]
  _not: towers_bool_exp
  _or: [towers_bool_exp]
  col: integer_comparison_exp
  id: integer_comparison_exp
  progress: numeric_comparison_exp
  row: integer_comparison_exp
}

# unique or primary key constraints on table "towers"
enum towers_constraint {
  # unique or primary key constraint
  towers_pkey
}

# input type for incrementing integer columne in table "towers"
input towers_inc_input {
  col: Int
  id: Int
  row: Int
}

# input type for inserting data into table "towers"
input towers_insert_input {
  col: Int
  id: Int
  progress: numeric
  row: Int
}

# aggregate max on columns
type towers_max_fields {
  col: Int
  id: Int
  progress: numeric
  row: Int
}

# order by max() on columns of table "towers"
input towers_max_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# aggregate min on columns
type towers_min_fields {
  col: Int
  id: Int
  progress: numeric
  row: Int
}

# order by min() on columns of table "towers"
input towers_min_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# response of any mutation on the table "towers"
type towers_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [towers!]!
}

# input type for inserting object relation for remote table "towers"
input towers_obj_rel_insert_input {
  data: towers_insert_input!
  on_conflict: towers_on_conflict
}

# on conflict condition type for table "towers"
input towers_on_conflict {
  constraint: towers_constraint!
  update_columns: [towers_update_column!]!
}

# ordering options when selecting data from "towers"
input towers_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# select columns of table "towers"
enum towers_select_column {
  # column name
  col

  # column name
  id

  # column name
  progress

  # column name
  row
}

# input type for updating data in table "towers"
input towers_set_input {
  col: Int
  id: Int
  progress: numeric
  row: Int
}

# aggregate stddev on columns
type towers_stddev_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by stddev() on columns of table "towers"
input towers_stddev_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# aggregate stddev_pop on columns
type towers_stddev_pop_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by stddev_pop() on columns of table "towers"
input towers_stddev_pop_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# aggregate stddev_samp on columns
type towers_stddev_samp_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by stddev_samp() on columns of table "towers"
input towers_stddev_samp_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# aggregate sum on columns
type towers_sum_fields {
  col: Int
  id: Int
  progress: numeric
  row: Int
}

# order by sum() on columns of table "towers"
input towers_sum_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# update columns of table "towers"
enum towers_update_column {
  # column name
  col

  # column name
  id

  # column name
  progress

  # column name
  row
}

# aggregate var_pop on columns
type towers_var_pop_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by var_pop() on columns of table "towers"
input towers_var_pop_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# aggregate var_samp on columns
type towers_var_samp_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by var_samp() on columns of table "towers"
input towers_var_samp_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

# aggregate variance on columns
type towers_variance_fields {
  col: Float
  id: Float
  progress: Float
  row: Float
}

# order by variance() on columns of table "towers"
input towers_variance_order_by {
  col: order_by
  id: order_by
  progress: order_by
  row: order_by
}

